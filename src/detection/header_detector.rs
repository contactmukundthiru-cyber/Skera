//! Source code header and license notice detector — industry-leading analysis
//!
//! ## Overview
//!
//! Scans source files for SPDX headers, copyright blocks, and license
//! notices. Detects missing, tampered, or mismatched headers.
//!
//! ## Industry-Leading Features
//!
//! 1. **SPDX Expression Parsing** — handles compound expressions like
//!    `SPDX-License-Identifier: MIT AND Apache-2.0` and `(MIT OR GPL-2.0-only)`.
//!
//! 2. **Multi-License Detection** — identifies files with multiple license
//!    blocks (dual-licensed headers) and reports each separately.
//!
//! 3. **Comment Style Normalization** — strips `//`, `/* */`, `#`, `--`,
//!    `<!-- -->`, etc. before analysis, handling all major languages.
//!
//! 4. **Deep Copyright Extraction** — extracts copyright holders, year ranges,
//!    and email addresses from multiple copyright formats.
//!
//! 5. **License-In-Directive vs License-In-Comment** — distinguishes machine-
//!    readable SPDX identifiers from free-text license mentions.
//!
//! 6. **Shebang and Generated File Detection** — identifies generated files
//!    (code generators, protobuf, etc.) to reduce false positives.

use crate::license::{LicenseClassifier, LicenseId};
use crate::detection::{Violation, ViolationType, Severity};
use crate::detection::contamination::SpdxExpression;
use crate::evidence::EvidenceItem;
use once_cell::sync::Lazy;
use regex::Regex;
use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use walkdir::WalkDir;

// ─── Data Structures ────────────────────────────────────────────────

/// Detected header in a source file  
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DetectedHeader {
    pub file: PathBuf,
    /// Primary license detected
    pub license: LicenseId,
    /// All licenses found in the header (for multi-license files)
    pub all_licenses: Vec<LicenseId>,
    /// Parsed SPDX expression if an SPDX-License-Identifier was present
    pub spdx_expression: Option<String>,
    pub confidence: f64,
    pub line_range: (usize, usize),
    pub text: String,
    /// All detected copyright holders
    pub copyright_holders: Vec<CopyrightInfo>,
    /// Whether the header appears to be machine-readable (SPDX directive)
    pub is_spdx_directive: bool,
    /// Whether the file appears auto-generated
    pub is_generated: bool,
}

/// Parsed copyright information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CopyrightInfo {
    pub holder: String,
    pub year_start: Option<u16>,
    pub year_end: Option<u16>,
    pub email: Option<String>,
    pub line_number: usize,
    pub raw_text: String,
}

/// Summary of header analysis for a directory
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HeaderScanResult {
    pub total_files_scanned: usize,
    pub files_with_headers: usize,
    pub files_missing_headers: usize,
    pub files_mismatched: usize,
    pub files_generated_skipped: usize,
    pub unique_licenses: Vec<LicenseId>,
    pub unique_copyright_holders: Vec<String>,
    pub headers: Vec<DetectedHeader>,
    pub violations: Vec<Violation>,
}

// ─── Regex Patterns ─────────────────────────────────────────────────

static SPDX_IDENTIFIER_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"(?i)SPDX[- ]License[- ]Identifier:\s*(.+?)(?:\s*\*/|\s*-->|\s*$)")
        .expect("Invalid SPDX identifier regex")
});

static COPYRIGHT_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(
        r"(?i)(?:copyright|©|\(c\))\s+(?:(?:\d{4}\s*[-–]\s*\d{4}|\d{4})\s*,?\s*)*(.+?)(?:\.\s*(?:All|Licensed)|$)"
    )
    .expect("Invalid copyright regex")
});

static YEAR_RANGE_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"((?:19|20)\d{2})\s*[-–]\s*((?:19|20)\d{2})")
        .expect("Invalid year range regex")
});

static SINGLE_YEAR_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"\b((?:19|20)\d{2})\b").expect("Invalid year regex")
});

static EMAIL_RE: Lazy<Regex> = Lazy::new(|| {
    Regex::new(r"<([^>]+@[^>]+)>").expect("Invalid email regex")
});

/// Patterns indicating auto-generated files
static GENERATED_PATTERNS: Lazy<Vec<Regex>> = Lazy::new(|| {
    vec![
        Regex::new(r"(?i)(?:auto[- ]?generated|do not edit|machine generated)").unwrap(),
        Regex::new(r"(?i)generated by (?:protoc|protobuf|thrift|swagger|openapi|antlr|flex|bison|yacc)").unwrap(),
        Regex::new(r"(?i)@generated").unwrap(),
        Regex::new(r"(?i)THIS FILE IS GENERATED").unwrap(),
        Regex::new(r"(?i)Code generated by.*DO NOT EDIT").unwrap(),
    ]
});

// ─── Core Engine ────────────────────────────────────────────────────

/// Header detection engine
pub struct HeaderDetector {
    classifier: LicenseClassifier,
}

impl HeaderDetector {
    pub fn new() -> Self {
        Self {
            classifier: LicenseClassifier::new(),
        }
    }

    /// Full scan of a directory tree with comprehensive analysis.
    pub fn full_scan(
        &self,
        root: &Path,
        project_license: &LicenseId,
    ) -> HeaderScanResult {
        let mut result = HeaderScanResult {
            total_files_scanned: 0,
            files_with_headers: 0,
            files_missing_headers: 0,
            files_mismatched: 0,
            files_generated_skipped: 0,
            unique_licenses: Vec::new(),
            unique_copyright_holders: Vec::new(),
            headers: Vec::new(),
            violations: Vec::new(),
        };

        let mut license_set = std::collections::HashSet::new();
        let mut holder_set = std::collections::HashSet::new();

        for entry in WalkDir::new(root)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
            .filter(|e| is_source_file(e.path()))
            .filter(|e| !is_in_ignored_dir(e.path()))
        {
            result.total_files_scanned += 1;

            let content = match std::fs::read_to_string(entry.path()) {
                Ok(c) => c,
                Err(_) => continue,
            };

            let headers = self.detect_all_headers(&content, entry.path());

            if headers.is_empty() {
                // Check if generated
                if is_generated_content(&content) {
                    result.files_generated_skipped += 1;
                    continue;
                }

                result.files_missing_headers += 1;
                result.violations.push(Violation {
                    violation_type: ViolationType::MissingSpdxHeader,
                    severity: Severity::Low,
                    confidence: 0.95,
                    description: format!(
                        "Source file missing SPDX/license header: {}",
                        entry.path().display()
                    ),
                    files: vec![entry.path().to_path_buf()],
                    licenses: vec![project_license.clone()],
                    obligations_violated: vec![],
                    evidence: vec![],
                    claimed_license: None,
                    actual_license: None,
                });
            } else {
                result.files_with_headers += headers.len();

                for header in &headers {
                    // Track unique licenses and holders
                    for lic in &header.all_licenses {
                        license_set.insert(lic.0.clone());
                    }
                    for holder in &header.copyright_holders {
                        holder_set.insert(holder.holder.clone());
                    }

                    // Check for mismatch with project license
                    if header.license != *project_license
                        && header.license.family() != project_license.family()
                        && header.confidence > 0.7
                        && !header.is_generated
                    {
                        // Check if this is a legitimate multi-license file
                        let is_dual_licensed = header.spdx_expression.as_ref()
                            .map(|expr| {
                                let parsed = SpdxExpression::parse(expr);
                                parsed.all_licenses().iter().any(|l| {
                                    LicenseId::new(l.as_str()) == *project_license
                                })
                            })
                            .unwrap_or(false);

                        if !is_dual_licensed {
                            result.files_mismatched += 1;
                            result.violations.push(Violation {
                                violation_type: ViolationType::ManifestLicenseMismatch,
                                severity: Severity::Medium,
                                confidence: header.confidence,
                                description: format!(
                                    "File {} has header claiming {} but project license is {}",
                                    header.file.display(),
                                    header.license,
                                    project_license
                                ),
                                files: vec![header.file.clone()],
                                licenses: vec![header.license.clone(), project_license.clone()],
                                obligations_violated: vec![],
                                evidence: vec![EvidenceItem {
                                    description: format!(
                                        "Header text (lines {}-{}): {}",
                                        header.line_range.0,
                                        header.line_range.1,
                                        &header.text[..header.text.len().min(200)]
                                    ),
                                    file_path: Some(header.file.clone()),
                                    line_number: Some(header.line_range.0),
                                    byte_offset: None,
                                    sha256: None,
                                    content_excerpt: Some(header.text.clone()),
                                    timestamp: chrono::Utc::now(),
                                }],
                                claimed_license: Some(header.license.clone()),
                                actual_license: Some(project_license.clone()),
                            });
                        }
                    }
                }

                result.headers.extend(headers);
            }
        }

        result.unique_licenses = license_set.into_iter().map(LicenseId::new).collect();
        result.unique_copyright_holders = holder_set.into_iter().collect();

        result
    }

    /// Scan a directory tree for license headers (backward compat)
    pub fn scan_directory(&self, root: &Path) -> Vec<DetectedHeader> {
        let mut headers = Vec::new();

        for entry in WalkDir::new(root)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
            .filter(|e| is_source_file(e.path()))
        {
            if let Ok(content) = std::fs::read_to_string(entry.path()) {
                let mut file_headers = self.detect_all_headers(&content, entry.path());
                headers.append(&mut file_headers);
            }
        }

        headers
    }

    /// Detect ALL license headers in a single file (supports multi-license).
    pub fn detect_all_headers(&self, content: &str, path: &Path) -> Vec<DetectedHeader> {
        let mut results = Vec::new();
        let is_gen = is_generated_content(content);

        // Phase 1: Check for SPDX-License-Identifier directives (machine-readable)
        for (line_num, line) in content.lines().enumerate().take(100) {
            if let Some(caps) = SPDX_IDENTIFIER_RE.captures(line) {
                if let Some(expr_match) = caps.get(1) {
                    let raw_expr = expr_match.as_str().trim().to_string();
                    let parsed = SpdxExpression::parse(&raw_expr);
                    let all_licenses: Vec<LicenseId> = parsed.all_licenses()
                        .into_iter()
                        .map(|l| LicenseId::new(l))
                        .collect();

                    let primary = all_licenses.first()
                        .cloned()
                        .unwrap_or_else(|| LicenseId::new("UNKNOWN"));

                    // Extract copyright from nearby lines
                    let copyrights = extract_copyrights_from_region(content, line_num, 20);

                    results.push(DetectedHeader {
                        file: path.to_path_buf(),
                        license: primary,
                        all_licenses,
                        spdx_expression: Some(raw_expr),
                        confidence: 0.99, // Machine-readable = high confidence
                        line_range: (line_num + 1, line_num + 1),
                        text: line.to_string(),
                        copyright_holders: copyrights,
                        is_spdx_directive: true,
                        is_generated: is_gen,
                    });
                }
            }
        }

        // Phase 2: If no SPDX directive, fall back to free-text analysis
        if results.is_empty() {
            let header_region: String = content
                .lines()
                .take(100)
                .collect::<Vec<_>>()
                .join("\n");

            // Normalize comment markers for better classification
            let cleaned = strip_comment_markers(&header_region);

            if let Some(classification) = self.classifier.classify(&cleaned) {
                let copyrights = extract_copyrights_from_region(content, 0, 100);

                // Determine line range
                let (start_line, end_line) = find_header_line_range(content);

                results.push(DetectedHeader {
                    file: path.to_path_buf(),
                    license: classification.license.clone(),
                    all_licenses: vec![classification.license],
                    spdx_expression: None,
                    confidence: classification.confidence,
                    line_range: (start_line, end_line),
                    text: header_region[..header_region.len().min(500)].to_string(),
                    copyright_holders: copyrights,
                    is_spdx_directive: false,
                    is_generated: is_gen,
                });
            }
        }

        results
    }

    /// Detect license header in a single file (backward compat — returns first)
    pub fn detect_header(&self, content: &str, path: &Path) -> Option<DetectedHeader> {
        self.detect_all_headers(content, path).into_iter().next()
    }

    /// Find files that are MISSING license headers (violation detection)
    pub fn find_missing_headers(
        &self,
        root: &Path,
        expected_license: &LicenseId,
    ) -> Vec<Violation> {
        let mut violations = Vec::new();

        for entry in WalkDir::new(root)
            .into_iter()
            .filter_map(|e| e.ok())
            .filter(|e| e.file_type().is_file())
            .filter(|e| is_source_file(e.path()))
            .filter(|e| !is_in_ignored_dir(e.path()))
        {
            if let Ok(content) = std::fs::read_to_string(entry.path()) {
                // Skip generated files
                if is_generated_content(&content) {
                    continue;
                }

                let headers = self.detect_all_headers(&content, entry.path());
                if headers.is_empty() {
                    violations.push(Violation {
                        violation_type: ViolationType::MissingSpdxHeader,
                        severity: Severity::Low,
                        confidence: 0.95,
                        description: format!(
                            "Source file missing SPDX/license header: {}",
                            entry.path().display()
                        ),
                        files: vec![entry.path().to_path_buf()],
                        licenses: vec![expected_license.clone()],
                        obligations_violated: vec![],
                        evidence: vec![],
                        claimed_license: None,
                        actual_license: None,
                    });
                }
            }
        }

        violations
    }

    /// Detect mismatched headers (file claims MIT but LICENSE file says GPL)
    pub fn find_mismatched_headers(
        &self,
        headers: &[DetectedHeader],
        project_license: &LicenseId,
    ) -> Vec<Violation> {
        let mut violations = Vec::new();

        for header in headers {
            if header.is_generated {
                continue; // Don't flag generated files
            }

            if header.license != *project_license
                && header.license.family() != project_license.family()
                && header.confidence > 0.7
            {
                // Check if dual-licensed and project license is one option
                let is_dual_licensed = header.all_licenses.contains(project_license);

                if !is_dual_licensed {
                    violations.push(Violation {
                        violation_type: ViolationType::ManifestLicenseMismatch,
                        severity: Severity::Medium,
                        confidence: header.confidence,
                        description: format!(
                            "File {} claims {} but project license is {}",
                            header.file.display(),
                            header.license,
                            project_license
                        ),
                        files: vec![header.file.clone()],
                        licenses: vec![header.license.clone(), project_license.clone()],
                        obligations_violated: vec![],
                        evidence: vec![EvidenceItem {
                            description: format!(
                                "Header text: {}",
                                &header.text[..header.text.len().min(200)]
                            ),
                            file_path: Some(header.file.clone()),
                            line_number: Some(header.line_range.0),
                            byte_offset: None,
                            sha256: None,
                            content_excerpt: Some(header.text.clone()),
                            timestamp: chrono::Utc::now(),
                        }],
                        claimed_license: Some(header.license.clone()),
                        actual_license: Some(project_license.clone()),
                    });
                }
            }
        }

        violations
    }

    /// Detect license header tampering — headers that look intentionally modified.
    pub fn detect_tampering(
        &self,
        headers: &[DetectedHeader],
        project_license: &LicenseId,
    ) -> Vec<Violation> {
        let mut violations = Vec::new();

        for header in headers {
            // Check for low-confidence matches that might indicate tampered headers
            if header.confidence > 0.3 && header.confidence < 0.7 {
                // If the file has a license-like header but it's badly matched,
                // it might have been intentionally modified
                let family = header.license.family();
                let project_family = project_license.family();

                // Suspicious: copyleft header weakened to look permissive
                if family.is_permissive() && project_family.is_copyleft() {
                    violations.push(Violation {
                        violation_type: ViolationType::LicenseTextTampering,
                        severity: Severity::High,
                        confidence: 0.6,
                        description: format!(
                            "File {} has a weak-confidence ({:.0}%) permissive header in a copyleft project — possible tampering",
                            header.file.display(),
                            header.confidence * 100.0
                        ),
                        files: vec![header.file.clone()],
                        licenses: vec![header.license.clone(), project_license.clone()],
                        obligations_violated: vec![],
                        evidence: vec![EvidenceItem {
                            description: format!(
                                "Suspicious header (confidence: {:.0}%): {}",
                                header.confidence * 100.0,
                                &header.text[..header.text.len().min(300)]
                            ),
                            file_path: Some(header.file.clone()),
                            line_number: Some(header.line_range.0),
                            byte_offset: None,
                            sha256: None,
                            content_excerpt: Some(header.text.clone()),
                            timestamp: chrono::Utc::now(),
                        }],
                        claimed_license: Some(header.license.clone()),
                        actual_license: Some(project_license.clone()),
                    });
                }
            }

            // Check for copyright year anomalies
            for cr in &header.copyright_holders {
                if let (Some(start), Some(end)) = (cr.year_start, cr.year_end) {
                    // Suspicious: copyright range extends into the future
                    if end > 2030 || start > end {
                        violations.push(Violation {
                            violation_type: ViolationType::LicenseTextTampering,
                            severity: Severity::Medium,
                            confidence: 0.75,
                            description: format!(
                                "Suspicious copyright year range ({}-{}) in {}",
                                start, end, header.file.display()
                            ),
                            files: vec![header.file.clone()],
                            licenses: vec![header.license.clone()],
                            obligations_violated: vec![],
                            evidence: vec![],
                            claimed_license: None,
                            actual_license: None,
                        });
                    }
                }
            }
        }

        violations
    }
}

impl Default for HeaderDetector {
    fn default() -> Self {
        Self::new()
    }
}

// ─── Utility Functions ──────────────────────────────────────────────

/// Strip comment markers from text for better license classification.
fn strip_comment_markers(text: &str) -> String {
    text.lines()
        .map(|line| {
            let trimmed = line.trim();
            // Strip various comment styles
            let stripped = if trimmed.starts_with("//") {
                trimmed[2..].trim()
            } else if trimmed.starts_with("/*") {
                trimmed[2..].trim().trim_end_matches("*/").trim()
            } else if trimmed.starts_with(" * ") || trimmed.starts_with(" *\t") {
                trimmed[2..].trim()
            } else if trimmed.starts_with("* ") {
                trimmed[2..].trim()
            } else if trimmed == "*/" {
                ""
            } else if trimmed.starts_with('#') && !trimmed.starts_with("#!") {
                trimmed[1..].trim()
            } else if trimmed.starts_with("--") {
                trimmed[2..].trim()
            } else if trimmed.starts_with(";;") {
                trimmed[2..].trim()
            } else if trimmed.starts_with("<!--") {
                trimmed[4..].trim().trim_end_matches("-->").trim()
            } else if trimmed.starts_with("rem ") || trimmed.starts_with("REM ") {
                trimmed[4..].trim()
            } else {
                trimmed
            };
            stripped.to_string()
        })
        .collect::<Vec<_>>()
        .join("\n")
}

/// Extract copyright information from a region of text.
fn extract_copyrights_from_region(content: &str, center_line: usize, radius: usize) -> Vec<CopyrightInfo> {
    let mut copyrights = Vec::new();
    let start = center_line.saturating_sub(radius);
    let end = center_line + radius;

    for (i, line) in content.lines().enumerate() {
        if i < start || i > end {
            continue;
        }

        let trimmed = line.trim();
        let lower = trimmed.to_lowercase();

        if lower.contains("copyright") || lower.contains("©") || lower.contains("(c)") {
            let mut holder = String::new();
            let mut year_start = None;
            let mut year_end = None;
            let mut email = None;

            // Extract year range
            if let Some(caps) = YEAR_RANGE_RE.captures(trimmed) {
                year_start = caps.get(1).and_then(|m| m.as_str().parse().ok());
                year_end = caps.get(2).and_then(|m| m.as_str().parse().ok());
            } else if let Some(m) = SINGLE_YEAR_RE.find(trimmed) {
                year_start = m.as_str().parse().ok();
                year_end = year_start;
            }

            // Extract email
            if let Some(caps) = EMAIL_RE.captures(trimmed) {
                email = caps.get(1).map(|m| m.as_str().to_string());
            }

            // Extract holder name
            if let Some(caps) = COPYRIGHT_RE.captures(trimmed) {
                if let Some(m) = caps.get(1) {
                    holder = m.as_str().trim().to_string();
                    // Clean up common trailing artifacts
                    holder = holder.trim_end_matches('.').trim().to_string();
                    if let Some(pos) = holder.find('<') {
                        holder = holder[..pos].trim().to_string();
                    }
                }
            }

            if !holder.is_empty() || year_start.is_some() {
                copyrights.push(CopyrightInfo {
                    holder: if holder.is_empty() { "Unknown".to_string() } else { holder },
                    year_start,
                    year_end,
                    email,
                    line_number: i + 1,
                    raw_text: trimmed.to_string(),
                });
            }
        }
    }

    copyrights
}

/// Find the line range of the license header in a file.
fn find_header_line_range(content: &str) -> (usize, usize) {
    let mut start_line = 0;
    let mut end_line = 0;

    for (i, line) in content.lines().enumerate().take(100) {
        let trimmed = line.trim().to_lowercase();
        if trimmed.contains("license")
            || trimmed.contains("copyright")
            || trimmed.contains("spdx")
            || trimmed.contains("permission is hereby granted")
            || trimmed.contains("redistribution and use")
            || trimmed.contains("gnu general public")
            || trimmed.contains("apache license")
            || trimmed.contains("mozilla public")
        {
            if start_line == 0 {
                start_line = i + 1;
            }
            end_line = i + 1;
        }
    }

    (start_line, end_line)
}

/// Check if content appears to be auto-generated code.
fn is_generated_content(content: &str) -> bool {
    // Check first 20 lines for generated markers
    let header: String = content.lines().take(20).collect::<Vec<_>>().join("\n");
    GENERATED_PATTERNS.iter().any(|re| re.is_match(&header))
}

/// Check if a file is a source code file worth scanning
fn is_source_file(path: &Path) -> bool {
    let ext = path
        .extension()
        .and_then(|e| e.to_str())
        .unwrap_or("");

    matches!(
        ext,
        "rs" | "py" | "js" | "ts" | "jsx" | "tsx" | "c" | "h" | "cpp" | "hpp"
            | "cc" | "cxx" | "java" | "kt" | "kts" | "scala" | "go" | "rb" | "php"
            | "cs" | "fs" | "vb" | "swift" | "m" | "mm" | "d" | "zig" | "nim"
            | "lua" | "pl" | "pm" | "r" | "R" | "jl" | "ex" | "exs" | "erl"
            | "hrl" | "hs" | "lhs" | "ml" | "mli" | "clj" | "cljs" | "cljc"
            | "el" | "lisp" | "rkt" | "scm" | "v" | "sv" | "vhd" | "vhdl"
            | "vue" | "svelte" | "dart" | "groovy" | "gradle"
    )
}

/// Check if a path is in a commonly ignored directory.
fn is_in_ignored_dir(path: &Path) -> bool {
    let path_str = path.to_string_lossy();
    let ignored = [
        "node_modules",
        ".git",
        "target",
        "build",
        "dist",
        "__pycache__",
        ".venv",
        "venv",
        ".tox",
        "vendor", // We handle vendor separately in attribution
        ".cargo",
        "elm-stuff",
    ];
    ignored.iter().any(|dir| {
        path_str.contains(&format!("/{}/", dir))
            || path_str.contains(&format!("\\{}\\", dir))
    })
}

// ─── Tests ──────────────────────────────────────────────────────────

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_spdx_directive_detection() {
        let detector = HeaderDetector::new();
        let content = r#"// SPDX-License-Identifier: MIT
// Copyright 2024 John Doe <john@example.com>
package main
"#;
        let headers = detector.detect_all_headers(content, Path::new("main.go"));
        assert!(!headers.is_empty());
        assert!(headers[0].is_spdx_directive);
        assert_eq!(headers[0].spdx_expression, Some("MIT".to_string()));
        assert!(headers[0].confidence > 0.95);
    }

    #[test]
    fn test_compound_spdx_directive() {
        let detector = HeaderDetector::new();
        let content = r#"// SPDX-License-Identifier: MIT OR Apache-2.0
// Copyright 2024 Acme Corp
fn main() {}
"#;
        let headers = detector.detect_all_headers(content, Path::new("main.rs"));
        assert!(!headers.is_empty());
        assert_eq!(headers[0].all_licenses.len(), 2);
    }

    #[test]
    fn test_copyright_extraction() {
        let content = r#"// Copyright 2020-2024 Jane Smith <jane@example.com>
// Licensed under MIT
fn main() {}
"#;
        let copyrights = extract_copyrights_from_region(content, 0, 10);
        assert!(!copyrights.is_empty());
        assert!(copyrights[0].holder.contains("Jane Smith") || copyrights[0].holder.contains("Smith"));
        assert_eq!(copyrights[0].year_start, Some(2020));
        assert_eq!(copyrights[0].year_end, Some(2024));
        assert_eq!(copyrights[0].email, Some("jane@example.com".to_string()));
    }

    #[test]
    fn test_generated_detection() {
        assert!(is_generated_content("// Code generated by protoc. DO NOT EDIT.\npackage foo"));
        assert!(is_generated_content("// @generated\nconst x = 1;"));
        assert!(!is_generated_content("fn main() { println!(\"hello\"); }"));
    }

    #[test]
    fn test_comment_stripping() {
        let input = "// Licensed under MIT\n * Copyright 2024\n# Apache License";
        let cleaned = strip_comment_markers(input);
        assert!(cleaned.contains("Licensed under MIT"));
        assert!(cleaned.contains("Copyright 2024"));
        assert!(cleaned.contains("Apache License"));
    }

    #[test]
    fn test_is_source_file() {
        assert!(is_source_file(Path::new("foo.rs")));
        assert!(is_source_file(Path::new("bar.py")));
        assert!(is_source_file(Path::new("baz.java")));
        assert!(!is_source_file(Path::new("readme.md")));
        assert!(!is_source_file(Path::new("data.json")));
    }
}
